/*
Copyright (c) 2022 Rune AI Inc.
All rights reserved.

This code is proprietary to Rune AI Inc.
The code may be used solely for accessing the Service provided by Rune AI Inc. following the Rune Terms of Service ("Terms") accessible at rune.ai/eula. You may not use this code for any use or purpose other than as expressly permitted by the Terms.
Restrictions set forth in the Terms include, but is not limited to, that you may not copy, adapt, modify, prepare derivative works based upon, distribute, license, sell, transfer, publicly display, publicly perform, transmit, stream, broadcast, attempt to discover any source code, reverse engineer, decompile, dissemble, or otherwise exploit the code as a whole or any portion of the code.
*/
declare global {
    var ReactNativeWebView: {
        postMessage: (data: string) => void;
    } | undefined;
}

type GameState = Record<string, any>;
type GameContext = {
    gameOver: GameOverContext | null;
    orderNumber: number;
    sessionId: SessionId;
    gameId: GameId;
};
type PlayersRandomState = Record<PlayerId, {
    seed: RandomSeed;
    actionCount: number;
}>;
type ServerSerializationData = {
    game: GameState;
    context: GameContext;
    random: PlayersRandomState;
    gameTime: number;
    updateCount: number;
};
type GameConfig = {
    minPlayers: number;
    maxPlayers: number;
    eventCallbacks: {
        playerLeft: boolean;
        playerJoined: boolean;
    };
    update: boolean;
};
type SessionId = string;
type GameId = number;
type PlayerId = string;
type RandomSeed = number;
type Player = {
    playerId: PlayerId;
    displayName: string;
    avatarUrl: string;
};
type Players = Record<PlayerId, Player>;
type UserId = number;
type Spectator = {
    playerId: undefined;
};
type User = (Player | Spectator) & {
    userId: number;
};
type Users = Record<UserId, User>;
type LogicContext = {
    randomSeed: RandomSeed;
    msPerTick: number;
    logicTick: number;
};
type ClientAction = (params?: any) => void;
type ClientActions = Record<string, ClientAction>;
type ServerLogicAction = (params: any, actionContext: {
    game: GameState;
    playerId: PlayerId;
}, logicContext: LogicContext) => {
    game: GameState;
    gameContext: RunGameLogicGameContext;
} | false;
type LogicUpdate<TypedGameState extends object> = ({ game, }: {
    game: TypedGameState;
}) => void;
type ServerLogicActions = Record<string, ServerLogicAction>;
type LogicEvents<TypedGameState extends object> = {
    playerJoined?: (playerId: PlayerId, eventContext: {
        game: TypedGameState;
    }) => void;
    playerLeft?: (playerId: PlayerId, eventContext: {
        game: TypedGameState;
    }) => void;
};
type ServerLogicEventContext<TypedGameState> = {
    game: TypedGameState;
};
type ServerLogicUpdateContext<TypedGameState> = {
    game: TypedGameState;
};
type ServerLogicActionContext<TypedGameState> = {
    game: TypedGameState;
    playerId: PlayerId;
};
type ServerLogicUpdate<TypedGameState extends object> = (updateContext: ServerLogicUpdateContext<TypedGameState>, logicContext: LogicContext) => {
    game: GameState;
    gameContext: RunGameLogicGameContext;
};
type ServerLogicEvents<TypedGameState extends object> = {
    playerJoined?: (playerId: PlayerId, eventContext: ServerLogicEventContext<TypedGameState>, logicContext: LogicContext) => {
        game: GameState;
        gameContext: RunGameLogicGameContext;
    };
    playerLeft?: (playerId: PlayerId, eventContext: ServerLogicEventContext<TypedGameState>, logicContext: LogicContext) => {
        game: GameState;
        gameContext: RunGameLogicGameContext;
    };
};
type GameOverOptions = {
    players: {
        [playerId: PlayerId]: "WON" | "LOST" | number;
    };
    delayPopUp?: boolean;
};
type InitLogicParams<TypedGameState extends object, GameActions extends ClientActions> = {
    minPlayers: number;
    maxPlayers: number;
    setup: (playerIds: PlayerId[]) => TypedGameState;
    actions: {
        [key in keyof GameActions]: (params: Parameters<GameActions[key]>[0], { game, playerId }: {
            game: TypedGameState;
            playerId: PlayerId;
        }) => void;
    };
    events?: LogicEvents<TypedGameState>;
    update?: LogicUpdate<TypedGameState>;
};
type RuneShared<TypedGameState extends object, GameActions extends ClientActions> = {
    initLogic: (params: InitLogicParams<TypedGameState, GameActions>) => void;
    invalidAction: () => Error;
    gameOver: (options?: GameOverOptions) => void;
    gameTimeInSeconds: () => number;
};
type RuneServer<TypedGameState extends object, GameActions extends ClientActions> = {
    gameConfig?: GameConfig;
    setup?: (playerIds: PlayerId[], logicContext: LogicContext) => GameState;
    actions?: ServerLogicActions;
    events?: ServerLogicEvents<TypedGameState> | undefined;
    logicContext: LogicContext;
    gameOverContext: GameOverContext | null;
    update?: ServerLogicUpdate<TypedGameState>;
} & RuneShared<TypedGameState, GameActions>;
type UpdateLoopContext = {
    logicTick: number;
};
type GameServer = {
    onMsg: (msgLogger: MsgLogger, userId: UserId, msg: string) => Promise<void>;
    onPlayerJoined: (msgLogger: MsgLogger, playerId: PlayerId) => Promise<void>;
    onPlayerLeft: (msgLogger: MsgLogger, playerId: PlayerId) => Promise<void>;
    getDataForSerialization: () => ServerSerializationData;
    getConfig: () => GameConfig;
    getSessionId: () => SessionId;
    getGameId: () => GameId;
    onUpdateLoop: (msgLogger: MsgLogger, updateLoopContext: UpdateLoopContext) => Promise<void>;
    cleanup: () => void;
};
type NetworkServer = {
    getUsers: () => Users;
    broadcastMsg: (msgLogger: MsgLogger, msg: string) => void;
    sendMsg: (msgLogger: MsgLogger, userId: UserId, msg: string) => void;
    onGameOver?: (reason: GameOverContext["reason"]) => void;
    queueUpdateLoop: (updateLoopContext: UpdateLoopContext) => void;
};
type RunGameLogicGameContext = {
    gameOver: GameOverContext | null;
};
type LogicReturnType = {
    game: GameState;
    gameContext: RunGameLogicGameContext;
};
type RunGameLogic = {
    getConfig: () => GameConfig;
    runSetup: (msgLogger: MsgLogger, playerIds: PlayerId[], logicContext: LogicContext) => Promise<GameState>;
    runEvent: (msgLogger: MsgLogger, logicContext: LogicContext, event: "playerJoined" | "playerLeft", playerId: PlayerId, eventContext: ServerLogicEventContext<GameState>) => Promise<LogicReturnType>;
    runAction: (msgLogger: MsgLogger, logicContext: LogicContext, action: string, params: any, actionContext: ServerLogicActionContext<GameState>) => Promise<LogicReturnType | false>;
    runUpdate: (msgLogger: MsgLogger, logicContext: LogicContext, updateContext: ServerLogicUpdateContext<GameState>) => Promise<LogicReturnType>;
};
type GameOverGameEnded = {
    reason: "gameEnded";
    options?: GameOverOptions;
};
type GameOverPlayerLeft = {
    reason: "playerLeft";
};
type GameOverMinPlayers = {
    reason: "minPlayers";
};
type GameOverError = {
    reason: "err";
};
type GameOverContext = (GameOverMinPlayers | GameOverPlayerLeft | GameOverGameEnded | GameOverError) & {
    players: Players;
};
type LogFn = {
    (obj: object, msg: string): void;
    (msg: string): void;
};
type MsgLogger = {
    error: LogFn;
    warn: LogFn;
    info: LogFn;
};

declare function isNewUserSpectator(users: Users, gameConfig: GameConfig, isGameOver: boolean): boolean;
declare function canSwitchSpectatorToPlayer(users: Users, gameConfig: GameConfig): boolean;

declare function createRuneSDKForLogicRunner(globalObject?: typeof globalThis): RuneServer<GameState, ClientActions>;

type CreateGameServerProps = {
    initialMsgLogger: MsgLogger;
    gameId: GameId;
    network: NetworkServer;
    logic: RunGameLogic;
    initialServerData?: ServerSerializationData | {
        sessionId: SessionId;
    };
    sendInitialStateSync?: boolean;
    getSeedForPlayerId?: (playerId: PlayerId) => number;
    serverSeed: RandomSeed;
    logicTimeoutDuration?: number;
    sendStateHash?: boolean;
    allowedGameTimeDelay?: number;
    logServerClientGameTime?: boolean;
    logNetworkMsg?: boolean;
};
declare function createGameServer({ initialMsgLogger, gameId, network, logic, initialServerData, sendInitialStateSync, getSeedForPlayerId, serverSeed, logicTimeoutDuration, sendStateHash, allowedGameTimeDelay, logServerClientGameTime, logNetworkMsg, }: CreateGameServerProps): Promise<GameServer>;

export { GameConfig, GameServer, GameState, RunGameLogic, RuneServer, ServerSerializationData, canSwitchSpectatorToPlayer, createGameServer, createRuneSDKForLogicRunner, isNewUserSpectator };
