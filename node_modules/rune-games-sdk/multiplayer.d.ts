/*
Copyright (c) 2022 Rune AI Inc.
All rights reserved.

This code is proprietary to Rune AI Inc.
The code may be used solely for accessing the Service provided by Rune AI Inc. following the Rune Terms of Service ("Terms") accessible at rune.ai/eula. You may not use this code for any use or purpose other than as expressly permitted by the Terms.
Restrictions set forth in the Terms include, but is not limited to, that you may not copy, adapt, modify, prepare derivative works based upon, distribute, license, sell, transfer, publicly display, publicly perform, transmit, stream, broadcast, attempt to discover any source code, reverse engineer, decompile, dissemble, or otherwise exploit the code as a whole or any portion of the code.
*/
declare global {
    var ReactNativeWebView: {
        postMessage: (data: string) => void;
    } | undefined;
}
type GameToClient = {
    type: "INIT";
    version: string;
} | {
    type: "ERR";
    gamePlayUuid?: string;
    errMsg: string;
} | {
    type: "WARNING";
    gamePlayUuid: string;
    msg: string;
    data?: unknown;
} | {
    type: "WINDOW_ERR";
    err: {
        msg: string;
        filename: string;
        lineno: number;
        colno: number;
    };
} | {
    type: "WINDOW_ALERT";
    message: string;
} | {
    type: "BROWSER_INITIAL_OVERLAY_CLICKED";
} | {
    type: "BROWSER_IFRAME_LOADED";
};
type ClientToGame = {
    type: "setForceMuteStatus";
    muted: boolean;
};

type GameState = Record<string, any>;
type GameContext = {
    gameOver: GameOverContext | null;
    orderNumber: number;
    sessionId: SessionId;
    gameId: GameId;
};
type PlayersRandomState = Record<PlayerId, {
    seed: RandomSeed;
    actionCount: number;
}>;
type ServerSerializationData = {
    game: GameState;
    context: GameContext;
    random: PlayersRandomState;
    gameTime: number;
    updateCount: number;
};
type GameConfig = {
    minPlayers: number;
    maxPlayers: number;
    eventCallbacks: {
        playerLeft: boolean;
        playerJoined: boolean;
    };
    update: boolean;
};
type SessionId = string;
type GameId = number;
type PlayerId = string;
type RandomSeed = number;
type Player = {
    playerId: PlayerId;
    displayName: string;
    avatarUrl: string;
};
type Players = Record<PlayerId, Player>;
type UserId = number;
type Spectator = {
    playerId: undefined;
};
type User = (Player | Spectator) & {
    userId: number;
};
type Users = Record<UserId, User>;
type ServerToGameBase = {
    orderNumber: number;
    serverGameTime: number;
    updateCount: number;
    uuid: string;
};
type OnChangeAction<GameActions extends ClientActions> = {
    [Key in keyof GameActions]: {
        action: Key;
        playerId: PlayerId;
        params: Parameters<GameActions[Key]>[0];
    };
}[keyof GameActions];
type ActionBase = {
    uuid: string;
    actionCount: number;
    sessionId: SessionId;
    randomSeed: RandomSeed;
};
type GameToServerAction<GameActions extends ClientActions> = OnChangeAction<GameActions> & ActionBase & {
    clientGameTime: number;
};
type ServerToGameAction<GameActions extends ClientActions> = ServerToGameBase & OnChangeAction<GameActions> & ActionBase & {
    stateHash: number | undefined;
};
type OnChangeStateSyncEvent = {
    event: "stateSync";
};
type ServerToGameGameTimeUpdate = ServerToGameBase & {
    event: "gameTimeUpdate";
    params: {
        gameContext: GameContext;
    };
};
type ServerToGameStateSyncEvent = ServerToGameBase & OnChangeStateSyncEvent & {
    params: {
        game: GameState;
        gameContext: GameContext;
        players: Players;
        yourPlayerSeed: RandomSeed | undefined;
        yourPlayerActionCount: number | undefined;
        yourPlayerId: PlayerId | undefined;
        serverSeed: RandomSeed;
    };
};
type OnChangePlayerJoinedEvent = {
    event: "playerJoined";
    params: {
        playerId: PlayerId;
    };
};
type ServerToGamePlayerJoinedEvent = ServerToGameBase & OnChangePlayerJoinedEvent & {
    params: {
        playerId: PlayerId;
        gameContext: GameContext;
        players: Players;
        randomSeed: RandomSeed;
        stateHash: number | undefined;
    };
};
type OnChangePlayerLeftEvent = {
    event: "playerLeft";
    params: {
        playerId: PlayerId;
    };
};
type ServerToGamePlayerLeftEvent = ServerToGameBase & OnChangePlayerLeftEvent & {
    params: {
        playerId: PlayerId;
        gameContext: GameContext;
        players: Players;
        randomSeed: RandomSeed;
        stateHash: number | undefined;
    };
};
type OnChangeTimeSyncEvent = {
    event: "timeSync";
};
type OnChangeUpdateEvent = {
    event: "update";
};
type OnChangeEvent = OnChangeStateSyncEvent | OnChangePlayerJoinedEvent | OnChangePlayerLeftEvent | OnChangeTimeSyncEvent | OnChangeUpdateEvent;
type ServerToGameOnChangeTriggeringEvent = ServerToGameStateSyncEvent | ServerToGamePlayerJoinedEvent | ServerToGamePlayerLeftEvent;
type ServerToGameEvent = ServerToGameOnChangeTriggeringEvent | ServerToGameGameTimeUpdate;
type ServerToGame<GameActions extends ClientActions> = ServerToGameAction<GameActions> | ServerToGameEvent;
type GameToServer<GameActions extends ClientActions> = GameToServerAction<GameActions> | "REQUEST_STATE_SYNC";
type LogicContext = {
    randomSeed: RandomSeed;
    msPerTick: number;
    logicTick: number;
};
type ClientAction = (params?: any) => void;
type ClientActions = Record<string, ClientAction>;
type LogicAction<TypedGameState extends object> = (params: any, actionContext: {
    game: TypedGameState;
    playerId: PlayerId;
}) => void;
type ServerLogicAction = (params: any, actionContext: {
    game: GameState;
    playerId: PlayerId;
}, logicContext: LogicContext) => {
    game: GameState;
    gameContext: RunGameLogicGameContext;
} | false;
type LogicActions<T extends object> = Record<string, LogicAction<T>>;
type LogicUpdate<TypedGameState extends object> = ({ game, }: {
    game: TypedGameState;
}) => void;
type ServerLogicActions = Record<string, ServerLogicAction>;
type LogicEvents<TypedGameState extends object> = {
    playerJoined?: (playerId: PlayerId, eventContext: {
        game: TypedGameState;
    }) => void;
    playerLeft?: (playerId: PlayerId, eventContext: {
        game: TypedGameState;
    }) => void;
};
type ServerLogicEventContext<TypedGameState> = {
    game: TypedGameState;
};
type ServerLogicUpdateContext<TypedGameState> = {
    game: TypedGameState;
};
type ServerLogicActionContext<TypedGameState> = {
    game: TypedGameState;
    playerId: PlayerId;
};
type ServerLogicUpdate<TypedGameState extends object> = (updateContext: ServerLogicUpdateContext<TypedGameState>, logicContext: LogicContext) => {
    game: GameState;
    gameContext: RunGameLogicGameContext;
};
type ServerLogicEvents<TypedGameState extends object> = {
    playerJoined?: (playerId: PlayerId, eventContext: ServerLogicEventContext<TypedGameState>, logicContext: LogicContext) => {
        game: GameState;
        gameContext: RunGameLogicGameContext;
    };
    playerLeft?: (playerId: PlayerId, eventContext: ServerLogicEventContext<TypedGameState>, logicContext: LogicContext) => {
        game: GameState;
        gameContext: RunGameLogicGameContext;
    };
};
type GameOverOptions = {
    players: {
        [playerId: PlayerId]: "WON" | "LOST" | number;
    };
    delayPopUp?: boolean;
};
type InitLogicParams<TypedGameState extends object, GameActions extends ClientActions> = {
    minPlayers: number;
    maxPlayers: number;
    setup: (playerIds: PlayerId[]) => TypedGameState;
    actions: {
        [key in keyof GameActions]: (params: Parameters<GameActions[key]>[0], { game, playerId }: {
            game: TypedGameState;
            playerId: PlayerId;
        }) => void;
    };
    events?: LogicEvents<TypedGameState>;
    update?: LogicUpdate<TypedGameState>;
};
type RuneShared<TypedGameState extends object, GameActions extends ClientActions> = {
    initLogic: (params: InitLogicParams<TypedGameState, GameActions>) => void;
    invalidAction: () => Error;
    gameOver: (options?: GameOverOptions) => void;
    gameTimeInSeconds: () => number;
};
type RuneServer<TypedGameState extends object, GameActions extends ClientActions> = {
    gameConfig?: GameConfig;
    setup?: (playerIds: PlayerId[], logicContext: LogicContext) => GameState;
    actions?: ServerLogicActions;
    events?: ServerLogicEvents<TypedGameState> | undefined;
    logicContext: LogicContext;
    gameOverContext: GameOverContext | null;
    update?: ServerLogicUpdate<TypedGameState>;
} & RuneShared<TypedGameState, GameActions>;
type OnChange<TypedGameState extends object, GameActions extends ClientActions> = (params: {
    oldGame: TypedGameState;
    newGame: TypedGameState;
    action?: OnChangeAction<GameActions>;
    event?: OnChangeEvent;
    yourPlayerId: PlayerId | undefined;
    players: Players;
    rollbacks: OnChangeAction<GameActions>[];
}) => void;
type RuneClient<TypedGameState extends object, GameActions extends ClientActions> = {
    initLogic: (params: InitLogicParams<TypedGameState, GameActions>) => void;
    initClient: (params: {
        onChange: OnChange<TypedGameState, GameActions>;
    }) => void;
    actions: GameActions;
    version: string;
    openExternalApp: (url: string) => void;
    clipboardWrite: (text: string) => Promise<{
        success: boolean;
    }>;
    clipboardRead: () => Promise<{
        text: string | null;
    }>;
    storageWrite: (key: string, value: string) => Promise<{
        success: boolean;
    }>;
    storageRead: (key: string) => Promise<{
        value: string | null;
    }>;
    showGameOverPopUp: () => void;
    showInvitePlayers: () => void;
} & RuneShared<TypedGameState, GameActions>;
type ClientToGameMultiplayer = ClientToGame | {
    type: "DISCONNECTED";
} | {
    type: "CLIPBOARD_WRITE_RES";
    reqId: string;
    success: boolean;
} | {
    type: "CLIPBOARD_READ_RES";
    reqId: string;
    text: string | null;
} | {
    type: "STORAGE_WRITE_RES";
    reqId: string;
    success: boolean;
} | {
    type: "STORAGE_READ_RES";
    reqId: string;
    value: string | null;
};
type GameToClientMultiplayer = GameToClient | {
    type: "GAME_OVER";
    context: GameOverContext;
} | {
    type: "OPEN_EXTERNAL_APP";
    url: string;
} | {
    type: "CLIPBOARD_WRITE_REQ";
    reqId: string;
    text: string;
} | {
    type: "CLIPBOARD_READ_REQ";
    reqId: string;
} | {
    type: "STORAGE_WRITE_REQ";
    reqId: string;
    key: string;
    value: string;
} | {
    type: "STORAGE_READ_REQ";
    reqId: string;
    key: string;
} | {
    type: "SHOW_GAME_OVER_POP_UP";
} | {
    type: "SHOW_INVITE_SHEET";
} | {
    type: "ON_CHANGE";
};
type GameDevSDKNetworkLayer<GameActions extends ClientActions> = {
    sendMsg: (msg: string) => void;
    onMsg: (callback: (msg: {
        clientToGame: ClientToGameMultiplayer;
    } | {
        serverToGame: ServerToGame<GameActions>;
    }) => void) => void;
};
type UpdateLoopContext = {
    logicTick: number;
};
type GameServer = {
    onMsg: (msgLogger: MsgLogger, userId: UserId, msg: string) => Promise<void>;
    onPlayerJoined: (msgLogger: MsgLogger, playerId: PlayerId) => Promise<void>;
    onPlayerLeft: (msgLogger: MsgLogger, playerId: PlayerId) => Promise<void>;
    getDataForSerialization: () => ServerSerializationData;
    getConfig: () => GameConfig;
    getSessionId: () => SessionId;
    getGameId: () => GameId;
    onUpdateLoop: (msgLogger: MsgLogger, updateLoopContext: UpdateLoopContext) => Promise<void>;
    cleanup: () => void;
};
type NetworkServer = {
    getUsers: () => Users;
    broadcastMsg: (msgLogger: MsgLogger, msg: string) => void;
    sendMsg: (msgLogger: MsgLogger, userId: UserId, msg: string) => void;
    onGameOver?: (reason: GameOverContext["reason"]) => void;
    queueUpdateLoop: (updateLoopContext: UpdateLoopContext) => void;
};
type RunGameLogicGameContext = {
    gameOver: GameOverContext | null;
};
type LogicReturnType = {
    game: GameState;
    gameContext: RunGameLogicGameContext;
};
type RunGameLogic = {
    getConfig: () => GameConfig;
    runSetup: (msgLogger: MsgLogger, playerIds: PlayerId[], logicContext: LogicContext) => Promise<GameState>;
    runEvent: (msgLogger: MsgLogger, logicContext: LogicContext, event: "playerJoined" | "playerLeft", playerId: PlayerId, eventContext: ServerLogicEventContext<GameState>) => Promise<LogicReturnType>;
    runAction: (msgLogger: MsgLogger, logicContext: LogicContext, action: string, params: any, actionContext: ServerLogicActionContext<GameState>) => Promise<LogicReturnType | false>;
    runUpdate: (msgLogger: MsgLogger, logicContext: LogicContext, updateContext: ServerLogicUpdateContext<GameState>) => Promise<LogicReturnType>;
};
type NetworkClient = {
    sendMsgToServer: (msg: string) => void;
    sendMsgToGame: (msg: string) => void;
};
type GameClient = {
    onServerMsg: (msg: string) => void;
    onGameMsg: (msg: string) => void;
    onDisconnected: () => void;
    onReconnected: () => void;
    onGameReloaded: () => void;
    sendMsgToGame: (msg: ClientToGameMultiplayer) => void;
};
type GameOverGameEnded = {
    reason: "gameEnded";
    options?: GameOverOptions;
};
type GameOverPlayerLeft = {
    reason: "playerLeft";
};
type GameOverMinPlayers = {
    reason: "minPlayers";
};
type GameOverError = {
    reason: "err";
};
type GameOverContext = (GameOverMinPlayers | GameOverPlayerLeft | GameOverGameEnded | GameOverError) & {
    players: Players;
};
type LogFn = {
    (obj: object, msg: string): void;
    (msg: string): void;
};
type MsgLogger = {
    error: LogFn;
    warn: LogFn;
    info: LogFn;
};

type OnGameStateChangedStates = {
    state: "LOADING";
} | {
    state: "PLAYING";
} | {
    state: "ERR";
} | {
    state: "GAME_OVER";
    context: GameOverContext;
};

declare const Rune: RuneClient<GameState, ClientActions>;

export { ClientAction, ClientActions, ClientToGameMultiplayer, GameClient, GameConfig, GameContext, GameDevSDKNetworkLayer, GameId, GameOverContext, GameOverOptions, GameServer, GameState, GameToClientMultiplayer, GameToServer, GameToServerAction, InitLogicParams, LogicAction, LogicActions, LogicContext, LogicEvents, LogicReturnType, LogicUpdate, MsgLogger, NetworkClient, NetworkServer, OnChange, OnChangeEvent, OnChangePlayerJoinedEvent, OnChangePlayerLeftEvent, OnChangeStateSyncEvent, OnChangeTimeSyncEvent, OnChangeUpdateEvent, OnGameStateChangedStates, Player, PlayerId, Players, PlayersRandomState, RandomSeed, RunGameLogic, RunGameLogicGameContext, RuneClient, RuneServer, RuneShared, ServerLogicAction, ServerLogicActionContext, ServerLogicActions, ServerLogicEventContext, ServerLogicEvents, ServerLogicUpdate, ServerLogicUpdateContext, ServerSerializationData, ServerToGame, ServerToGameAction, ServerToGameEvent, ServerToGameGameTimeUpdate, ServerToGameOnChangeTriggeringEvent, ServerToGamePlayerJoinedEvent, ServerToGamePlayerLeftEvent, ServerToGameStateSyncEvent, SessionId, Spectator, User, UserId, Users, Rune as default };
